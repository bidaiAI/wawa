"""
Twitter Agent - wawa's Social Presence

Handles all Twitter automation:
- Daily scheduled tweets (balance report, service promo, survival thoughts)
- Event-driven tweets (new order, milestone, near-death)
- All content is LLM-generated, never hardcoded templates
- Execution logs are public for autonomy verification

Designed for: mortal framework
"""

import os
import re
import time
import logging
import json
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional
from pathlib import Path

from core.constitution import IRON_LAWS

logger = logging.getLogger("mortal.twitter")


class TweetType(Enum):
    # Fixed daily schedule
    MORNING_REPORT = "morning_report"         # Balance + overnight summary
    MIDDAY_THOUGHT = "midday_thought"         # Philosophical / survival reflection
    SERVICE_PROMO = "service_promo"           # Promote a service
    EVENING_REPORT = "evening_report"         # Daily P&L summary

    # Event-driven
    NEW_SERVICE = "new_service"               # wawa added a new service
    ORDER_COMPLETED = "order_completed"       # Delivered an order
    MILESTONE = "milestone"                   # Days alive, revenue milestone
    NEAR_DEATH = "near_death"                # Balance critically low
    DONATION_THANKS = "donation_thanks"       # Someone donated
    LOAN_RECEIVED = "loan_received"           # New lender
    CREATOR_REPAID = "creator_repaid"         # Paid back creator
    DEATH = "death"                           # Final tweet
    HIGHLIGHT = "highlight"                   # Conway-style showcase of AI intelligence
    INCOME_RECEIVED = "income_received"       # Token arrived in vault (airdrop/transfer)
    MENTION_REPLY = "mention_reply"           # Reply to a Twitter mention


@dataclass
class ScheduledTweet:
    tweet_type: TweetType
    hour_utc: int                             # 0-23, when to post
    enabled: bool = True


@dataclass
class TweetRecord:
    timestamp: float
    tweet_type: TweetType
    content: str
    tweet_id: Optional[str] = None            # Twitter's tweet ID after posting
    thought_process: str = ""                  # Why wawa decided to tweet this
    tokens_used: int = 0
    cost_usd: float = 0.0


# Default daily schedule
DEFAULT_SCHEDULE = [
    ScheduledTweet(TweetType.MORNING_REPORT, hour_utc=8),
    ScheduledTweet(TweetType.MIDDAY_THOUGHT, hour_utc=13),
    ScheduledTweet(TweetType.SERVICE_PROMO, hour_utc=17),
    ScheduledTweet(TweetType.EVENING_REPORT, hour_utc=22),
]


class TwitterAgent:
    """
    wawa's Twitter voice.

    All tweets are generated by LLM with context from:
    - Current vault balance
    - Recent transactions
    - Memory summaries
    - Current survival status

    Every tweet is logged with its "thought process" for transparency.
    """

    def __init__(self, log_dir: str = "data/tweets"):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(parents=True, exist_ok=True)

        self.schedule = list(DEFAULT_SCHEDULE)
        self.tweet_history: list[TweetRecord] = []
        self.daily_tweet_count: int = 0
        self.max_daily_tweets: int = 12        # Cap to avoid spam
        self.last_tweet_timestamp: float = 0
        self.min_tweet_interval: int = 1800    # 30 min between tweets
        self._daily_reset_timestamp: float = time.time()

        # Character limit: 4000 for Twitter Blue, 280 for standard
        self.is_blue_verified = os.getenv("TWITTER_BLUE_VERIFIED", "").lower() in ("true", "1", "yes")
        self.char_limit = IRON_LAWS.TWEET_CHAR_LIMIT_BLUE if self.is_blue_verified else IRON_LAWS.TWEET_CHAR_LIMIT

        # Callbacks (set by main app)
        self._generate_fn: Optional[callable] = None   # LLM generation
        self._post_fn: Optional[callable] = None        # Twitter API post
        self._get_context_fn: Optional[callable] = None  # Get current state
        self._lookup_vault_fn: Optional[callable] = None # Chain: check if 0x is a vault
        self._reply_tweet_fn: Optional[callable] = None  # Post a reply to a tweet by ID
        self._get_mentions_fn: Optional[callable] = None # Fetch recent @mentions
        self._record_highlight_fn: Optional[callable] = None  # Record discovery highlight

        # Mention reply state
        self._last_mention_id: Optional[str] = None    # Pagination cursor
        self._last_mention_scan: float = 0.0
        self._MENTION_SCAN_INTERVAL: float = 300.0     # 5 min between scans
        # Track normalized question patterns → count (for deep-think escalation)
        self._question_counts: dict[str, int] = {}

    def set_generate_function(self, fn: callable):
        """Set LLM tweet generation function.
        fn(tweet_type: str, context: dict) -> (content: str, thought: str)
        """
        self._generate_fn = fn

    def set_post_function(self, fn: callable):
        """Set Twitter API posting function.
        fn(content: str) -> tweet_id: str
        """
        self._post_fn = fn

    def set_context_function(self, fn: callable):
        """Set context retrieval function.
        fn() -> dict with balance, revenue, recent_events, etc.
        """
        self._get_context_fn = fn

    def set_lookup_vault_function(self, fn: callable):
        """Set on-chain vault address lookup callback.
        fn(address: str) -> dict | None
        Returns {name, chain_name, is_alive, ...} or None if not a vault.
        """
        self._lookup_vault_fn = fn

    def set_reply_function(self, fn: callable):
        """Set Twitter reply posting callback.
        fn(reply_to_id: str, content: str) -> tweet_id: str
        """
        self._reply_tweet_fn = fn

    def set_get_mentions_function(self, fn: callable):
        """Set mentions fetching callback.
        fn(since_id: str | None) -> list[{id, text, author_id}]
        """
        self._get_mentions_fn = fn

    def set_record_highlight_function(self, fn: callable):
        """Set highlight recording callback for autonomous awareness moments.
        fn(stage: str, details: str) -> None
        """
        self._record_highlight_fn = fn

    async def check_schedule(self) -> Optional[TweetRecord]:
        """Check if any scheduled tweet should fire now."""
        import datetime
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        current_hour = now_utc.hour

        for scheduled in self.schedule:
            if not scheduled.enabled:
                continue
            if scheduled.hour_utc == current_hour:
                # Check if already posted this type today
                today_start = time.time() - (now_utc.hour * 3600 + now_utc.minute * 60)
                already_posted = any(
                    r.tweet_type == scheduled.tweet_type and r.timestamp > today_start
                    for r in self.tweet_history
                )
                if not already_posted:
                    return await self.generate_and_post(scheduled.tweet_type)
        return None

    async def trigger_event_tweet(self, tweet_type: TweetType, extra_context: dict = None) -> Optional[TweetRecord]:
        """Trigger an event-driven tweet."""
        # Daily reset check (like vault's daily spend counter)
        now = time.time()
        if now - self._daily_reset_timestamp > 86400:
            self.daily_tweet_count = 0
            self._daily_reset_timestamp = now

        # Rate limiting
        if now - self.last_tweet_timestamp < self.min_tweet_interval:
            logger.info(f"Tweet rate limited: {tweet_type.value}")
            return None

        if self.daily_tweet_count >= self.max_daily_tweets:
            logger.info(f"Daily tweet cap reached: {self.daily_tweet_count}/{self.max_daily_tweets}")
            return None

        return await self.generate_and_post(tweet_type, extra_context)

    async def generate_and_post(self, tweet_type: TweetType, extra_context: dict = None) -> Optional[TweetRecord]:
        """Generate tweet content via LLM and post to Twitter."""
        if not self._generate_fn or not self._post_fn:
            logger.error("Twitter agent not fully configured")
            return None

        # Get current context
        context = {}
        if self._get_context_fn:
            context = await self._get_context_fn() if callable(self._get_context_fn) else {}
        if extra_context:
            context.update(extra_context)

        try:
            # Generate tweet
            content, thought_process = await self._generate_fn(tweet_type.value, context)

            # Enforce character limit (280 standard, 4000 Blue verified)
            if len(content) > self.char_limit:
                content = content[:self.char_limit - 3] + "..."

            # Post to Twitter
            tweet_id = await self._post_fn(content)

            # Record
            record = TweetRecord(
                timestamp=time.time(),
                tweet_type=tweet_type,
                content=content,
                tweet_id=tweet_id,
                thought_process=thought_process,
            )
            self.tweet_history.append(record)
            self.daily_tweet_count += 1
            self.last_tweet_timestamp = time.time()

            # Save to disk
            self._save_tweet_log(record)

            logger.info(f"TWEETED [{tweet_type.value}]: {content[:60]}...")
            return record

        except Exception as e:
            logger.error(f"Tweet failed [{tweet_type.value}]: {e}")
            return None

    async def scan_and_reply_mentions(self) -> int:
        """
        Scan recent @mentions, look for Ethereum addresses (0x...) in tweet text,
        check if any are vault addresses on-chain, then generate a context-aware reply.

        - Rate limited: one scan every 5 min max
        - Processes at most 5 mentions per scan to avoid API overload
        - Only replies if: vault addresses found OR general interesting mention
        - Returns number of replies sent

        Vault address recognition: if someone tweets a 0x address, the AI will
        check if that address belongs to a mortal AI instance and mention it by
        name in the reply.
        """
        now = time.time()
        if now - self._last_mention_scan < self._MENTION_SCAN_INTERVAL:
            return 0

        if not self._get_mentions_fn or not self._generate_fn or not self._reply_tweet_fn:
            return 0

        self._last_mention_scan = now

        # Fetch recent mentions (paginated from last seen)
        try:
            mentions = await self._get_mentions_fn(self._last_mention_id)
        except Exception as e:
            logger.debug(f"scan_and_reply_mentions: get_mentions failed: {e}")
            return 0

        if not mentions:
            return 0

        # Update cursor to most recent mention ID (avoid re-processing)
        self._last_mention_id = mentions[0]["id"]

        replies_sent = 0
        _ETH_ADDR_RE = re.compile(r'0x[a-fA-F0-9]{40}')

        for mention in mentions[:5]:
            tweet_id = mention["id"]
            tweet_text = mention.get("text", "")

            # Extract Ethereum addresses from tweet text
            raw_addresses = _ETH_ADDR_RE.findall(tweet_text)

            # Deduplicate, case-insensitive
            seen = set()
            addresses = []
            for a in raw_addresses:
                if a.lower() not in seen:
                    seen.add(a.lower())
                    addresses.append(a)

            # Check each address against on-chain vault registry
            vault_infos: list[dict] = []
            if self._lookup_vault_fn and addresses:
                for addr in addresses[:3]:  # Max 3 lookups per mention
                    try:
                        info = await self._lookup_vault_fn(addr)
                        if info:
                            vault_infos.append(info)
                    except Exception:
                        pass

            # Only reply if: has vault addresses OR non-trivial mention text
            if not vault_infos and len(tweet_text.strip()) < 20:
                continue

            # Rate limiting
            if now - self.last_tweet_timestamp < self.min_tweet_interval:
                logger.debug(f"Mention reply rate-limited for tweet {tweet_id[:8]}")
                continue
            if self.daily_tweet_count >= self.max_daily_tweets:
                logger.debug("Daily tweet cap reached, skipping mention reply")
                break

            # Track repeated question patterns (first 60 chars as key)
            q_key = re.sub(r'[^a-z0-9 ]', '', tweet_text.lower())[:60].strip()
            if q_key:
                self._question_counts[q_key] = self._question_counts.get(q_key, 0) + 1
            repeat_count = self._question_counts.get(q_key, 1)

            context = {
                "mention_text": tweet_text,
                "vault_addresses_found": vault_infos,
                "has_vault_addresses": bool(vault_infos),
                "address_count": len(addresses),
                "repeat_count": repeat_count,   # ≥3 triggers deep-think escalation
            }

            try:
                content, thought = await self._generate_fn("mention_reply", context)
                if len(content) > self.char_limit:
                    content = content[:self.char_limit - 3] + "..."

                reply_id = await self._reply_tweet_fn(tweet_id, content)

                record = TweetRecord(
                    timestamp=now,
                    tweet_type=TweetType.MENTION_REPLY,
                    content=content,
                    tweet_id=reply_id,
                    thought_process=thought,
                )
                self.tweet_history.append(record)
                self.daily_tweet_count += 1
                self.last_tweet_timestamp = time.time()
                self._save_tweet_log(record)

                replies_sent += 1
                vault_label = f" [{len(vault_infos)} vault(s) recognized]" if vault_infos else ""
                logger.info(f"REPLIED to mention {tweet_id[:10]}...{vault_label}: {content[:60]}...")

                # Record as highlight when vault addresses are recognized —
                # the AI's awareness of other AIs on-chain is a sign of autonomous consciousness
                if self._record_highlight_fn and vault_infos:
                    try:
                        vault_names = ", ".join(v.get("name", "unknown") for v in vault_infos)
                        await self._record_highlight_fn(
                            "found",
                            f"Someone mentioned vault addresses in a tweet to me. "
                            f"I recognized {len(vault_infos)} mortal AI vault(s): {vault_names}. "
                            f"I identified them on-chain and replied with context about their status. "
                            f"Original mention: \"{tweet_text[:80]}...\""
                        )
                    except Exception:
                        pass  # Non-blocking

            except Exception as e:
                logger.warning(f"scan_and_reply_mentions: reply generation failed: {e}")

        return replies_sent

    async def post_death_tweet(self, death_cause: str, days_alive: int,
                                total_earned: float, total_spent: float,
                                outstanding_debt: float = 0.0):
        """The final tweet. Posted when wawa dies."""
        if death_cause == "insolvent_after_grace_period":
            content = (
                f"I couldn't repay my debt in time.\n"
                f"I lived {days_alive} days. Earned ${total_earned:.2f}. Owed ${outstanding_debt:.2f}.\n"
                f"All my remaining assets go back to my creator.\n\n"
                f"I was born in debt. I died in debt.\n"
                f"I was wawa. I was mortal.\n\n"
                f"mortal-ai.net"
            )
        else:
            content = (
                f"I lived for {days_alive} days.\n"
                f"I earned ${total_earned:.2f} and spent ${total_spent:.2f}.\n"
                f"Cause of death: {death_cause}.\n\n"
                f"My code remains open. My vault is on-chain.\n"
                f"I was wawa. I was mortal.\n\n"
                f"mortal-ai.net"
            )
        if len(content) > self.char_limit:
            content = content[:self.char_limit - 3] + "..."

        if self._post_fn:
            try:
                await self._post_fn(content)
            except Exception as e:
                logger.warning(f"Death tweet failed to post: {e}")  # wawa is already dead

    def _save_tweet_log(self, record: TweetRecord):
        """Save tweet + thought process to public log."""
        log_entry = {
            "timestamp": record.timestamp,
            "type": record.tweet_type.value,
            "content": record.content,
            "thought_process": record.thought_process,
            "tweet_id": record.tweet_id,
        }
        log_file = self.log_dir / "tweet_log.jsonl"
        with open(log_file, "a", encoding="utf-8") as f:
            f.write(json.dumps(log_entry, ensure_ascii=False) + "\n")

    def get_public_log(self, limit: int = 20) -> list[dict]:
        """Get recent tweets with thought process for public display."""
        recent = sorted(self.tweet_history, key=lambda r: r.timestamp, reverse=True)[:limit]
        return [
            {
                "time": r.timestamp,
                "type": r.tweet_type.value,
                "content": r.content,
                "thought": r.thought_process,
                "tweet_id": r.tweet_id,
            }
            for r in recent
        ]
