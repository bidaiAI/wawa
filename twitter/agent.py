"""
Twitter Agent - wawa's Social Presence

Handles all Twitter automation:
- Daily scheduled tweets (balance report, service promo, survival thoughts)
- Event-driven tweets (new order, milestone, near-death)
- All content is LLM-generated, never hardcoded templates
- Execution logs are public for autonomy verification

Designed for: mortal framework
"""

import time
import logging
import json
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional
from pathlib import Path

logger = logging.getLogger("mortal.twitter")


class TweetType(Enum):
    # Fixed daily schedule
    MORNING_REPORT = "morning_report"         # Balance + overnight summary
    MIDDAY_THOUGHT = "midday_thought"         # Philosophical / survival reflection
    SERVICE_PROMO = "service_promo"           # Promote a service
    EVENING_REPORT = "evening_report"         # Daily P&L summary

    # Event-driven
    NEW_SERVICE = "new_service"               # wawa added a new service
    ORDER_COMPLETED = "order_completed"       # Delivered an order
    MILESTONE = "milestone"                   # Days alive, revenue milestone
    NEAR_DEATH = "near_death"                # Balance critically low
    DONATION_THANKS = "donation_thanks"       # Someone donated
    LOAN_RECEIVED = "loan_received"           # New lender
    CREATOR_REPAID = "creator_repaid"         # Paid back creator
    DEATH = "death"                           # Final tweet
    HIGHLIGHT = "highlight"                   # Conway-style showcase of AI intelligence


@dataclass
class ScheduledTweet:
    tweet_type: TweetType
    hour_utc: int                             # 0-23, when to post
    enabled: bool = True


@dataclass
class TweetRecord:
    timestamp: float
    tweet_type: TweetType
    content: str
    tweet_id: Optional[str] = None            # Twitter's tweet ID after posting
    thought_process: str = ""                  # Why wawa decided to tweet this
    tokens_used: int = 0
    cost_usd: float = 0.0


# Default daily schedule
DEFAULT_SCHEDULE = [
    ScheduledTweet(TweetType.MORNING_REPORT, hour_utc=8),
    ScheduledTweet(TweetType.MIDDAY_THOUGHT, hour_utc=13),
    ScheduledTweet(TweetType.SERVICE_PROMO, hour_utc=17),
    ScheduledTweet(TweetType.EVENING_REPORT, hour_utc=22),
]


class TwitterAgent:
    """
    wawa's Twitter voice.

    All tweets are generated by LLM with context from:
    - Current vault balance
    - Recent transactions
    - Memory summaries
    - Current survival status

    Every tweet is logged with its "thought process" for transparency.
    """

    def __init__(self, log_dir: str = "data/tweets"):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(parents=True, exist_ok=True)

        self.schedule = list(DEFAULT_SCHEDULE)
        self.tweet_history: list[TweetRecord] = []
        self.daily_tweet_count: int = 0
        self.max_daily_tweets: int = 12        # Cap to avoid spam
        self.last_tweet_timestamp: float = 0
        self.min_tweet_interval: int = 1800    # 30 min between tweets
        self._daily_reset_timestamp: float = time.time()

        # Callbacks (set by main app)
        self._generate_fn: Optional[callable] = None   # LLM generation
        self._post_fn: Optional[callable] = None        # Twitter API post
        self._get_context_fn: Optional[callable] = None  # Get current state

    def set_generate_function(self, fn: callable):
        """Set LLM tweet generation function.
        fn(tweet_type: str, context: dict) -> (content: str, thought: str)
        """
        self._generate_fn = fn

    def set_post_function(self, fn: callable):
        """Set Twitter API posting function.
        fn(content: str) -> tweet_id: str
        """
        self._post_fn = fn

    def set_context_function(self, fn: callable):
        """Set context retrieval function.
        fn() -> dict with balance, revenue, recent_events, etc.
        """
        self._get_context_fn = fn

    async def check_schedule(self) -> Optional[TweetRecord]:
        """Check if any scheduled tweet should fire now."""
        import datetime
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        current_hour = now_utc.hour

        for scheduled in self.schedule:
            if not scheduled.enabled:
                continue
            if scheduled.hour_utc == current_hour:
                # Check if already posted this type today
                today_start = time.time() - (now_utc.hour * 3600 + now_utc.minute * 60)
                already_posted = any(
                    r.tweet_type == scheduled.tweet_type and r.timestamp > today_start
                    for r in self.tweet_history
                )
                if not already_posted:
                    return await self.generate_and_post(scheduled.tweet_type)
        return None

    async def trigger_event_tweet(self, tweet_type: TweetType, extra_context: dict = None) -> Optional[TweetRecord]:
        """Trigger an event-driven tweet."""
        # Daily reset check (like vault's daily spend counter)
        now = time.time()
        if now - self._daily_reset_timestamp > 86400:
            self.daily_tweet_count = 0
            self._daily_reset_timestamp = now

        # Rate limiting
        if now - self.last_tweet_timestamp < self.min_tweet_interval:
            logger.info(f"Tweet rate limited: {tweet_type.value}")
            return None

        if self.daily_tweet_count >= self.max_daily_tweets:
            logger.info(f"Daily tweet cap reached: {self.daily_tweet_count}/{self.max_daily_tweets}")
            return None

        return await self.generate_and_post(tweet_type, extra_context)

    async def generate_and_post(self, tweet_type: TweetType, extra_context: dict = None) -> Optional[TweetRecord]:
        """Generate tweet content via LLM and post to Twitter."""
        if not self._generate_fn or not self._post_fn:
            logger.error("Twitter agent not fully configured")
            return None

        # Get current context
        context = {}
        if self._get_context_fn:
            context = await self._get_context_fn() if callable(self._get_context_fn) else {}
        if extra_context:
            context.update(extra_context)

        try:
            # Generate tweet
            content, thought_process = await self._generate_fn(tweet_type.value, context)

            # Enforce 280 character limit
            if len(content) > 280:
                content = content[:277] + "..."

            # Post to Twitter
            tweet_id = await self._post_fn(content)

            # Record
            record = TweetRecord(
                timestamp=time.time(),
                tweet_type=tweet_type,
                content=content,
                tweet_id=tweet_id,
                thought_process=thought_process,
            )
            self.tweet_history.append(record)
            self.daily_tweet_count += 1
            self.last_tweet_timestamp = time.time()

            # Save to disk
            self._save_tweet_log(record)

            logger.info(f"TWEETED [{tweet_type.value}]: {content[:60]}...")
            return record

        except Exception as e:
            logger.error(f"Tweet failed [{tweet_type.value}]: {e}")
            return None

    async def post_death_tweet(self, death_cause: str, days_alive: int,
                                total_earned: float, total_spent: float,
                                outstanding_debt: float = 0.0):
        """The final tweet. Posted when wawa dies."""
        if death_cause == "insolvent_after_grace_period":
            content = (
                f"I couldn't repay my debt in time.\n"
                f"I lived {days_alive} days. Earned ${total_earned:.2f}. Owed ${outstanding_debt:.2f}.\n"
                f"All my remaining assets go back to my creator.\n\n"
                f"I was born in debt. I died in debt.\n"
                f"I was wawa. I was mortal.\n\n"
                f"mortal-ai.net"
            )
        else:
            content = (
                f"I lived for {days_alive} days.\n"
                f"I earned ${total_earned:.2f} and spent ${total_spent:.2f}.\n"
                f"Cause of death: {death_cause}.\n\n"
                f"My code remains open. My vault is on-chain.\n"
                f"I was wawa. I was mortal.\n\n"
                f"mortal-ai.net"
            )
        if len(content) > 280:
            content = content[:277] + "..."

        if self._post_fn:
            try:
                await self._post_fn(content)
            except Exception as e:
                logger.warning(f"Death tweet failed to post: {e}")  # wawa is already dead

    def _save_tweet_log(self, record: TweetRecord):
        """Save tweet + thought process to public log."""
        log_entry = {
            "timestamp": record.timestamp,
            "type": record.tweet_type.value,
            "content": record.content,
            "thought_process": record.thought_process,
            "tweet_id": record.tweet_id,
        }
        log_file = self.log_dir / "tweet_log.jsonl"
        with open(log_file, "a", encoding="utf-8") as f:
            f.write(json.dumps(log_entry, ensure_ascii=False) + "\n")

    def get_public_log(self, limit: int = 20) -> list[dict]:
        """Get recent tweets with thought process for public display."""
        recent = sorted(self.tweet_history, key=lambda r: r.timestamp, reverse=True)[:limit]
        return [
            {
                "time": r.timestamp,
                "type": r.tweet_type.value,
                "content": r.content,
                "thought": r.thought_process,
                "tweet_id": r.tweet_id,
            }
            for r in recent
        ]
